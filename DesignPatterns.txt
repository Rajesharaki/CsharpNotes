1) Why do we need Design Patterns?

* How to properly create a class
* How to interact between object
* How to write LooseCoupling code
* How to write Reusable Code

2) What is Design Pattern?

* A Well Defind solution to a Common Problem
* Industry Standard Apporpach
* Template, Not a solution
* Language Independent

3)Benfits of Design Pattern?

* Robust code
* Code Reusability
* Highly Maintainability
* We can achive loose coupling application

4)Types Of Design Pattern?S

1.Structural Design Pattern Ex:Adapter,Facade,Bridge/-
2.Creational Design Pattern Ex:Singleton,Factory,Bridge Etc/-
3.Behaviour Design Pattern Ex:Strategy,Observer,iterator Etc/-

5)Best Practice in Design Pattern

*Keep it simple
*Excess of everything is abd
*Focus on loose coupled code

Creational Design Pattern:
--------------------------
-->Singleton Pattern:
----------------------
                     If we need a class to have to only one project,then we use the singleton Pattern.

Advantages Of Singleton Pattern:
--------------------------------
* If several people have same requirement then it is not recommanded to create a separate object for
  every requirement. 
* we have to create only one object and we can reuse same object for every similar requirement so that performance and
  memory utilization will be improved

Class is not final but we are not allowed to create any child class:
----------------------------------------------------------------------
* Make constructor private.

Singleton Pattern:
-----------------
*Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists..
*The singleton class must provide a global access point to get the instance of the class.
*Singleton pattern is used for logging, drivers objects, caching and thread pool.
*Singleton design pattern is also used in other design patterns like Abstract Factory, Builder, Prototype, Facade etc.
*Singleton design pattern is used in core java classes also, for example java.lang.Runtime, java.awt.Desktop.

Singleton Pattern implememntation:
----------------------------------
To implement a Singleton pattern, we have different approaches but all of them have the following common concepts.

*Private constructor to restrict instantiation of the class from other classes.
*Private static variable of the same class that is the only instance of the class.
*Public static method that returns the instance of the class, this is the global access point for outer world to get the instance of the singleton class.

Different approaches of Singleton pattern implementation and design concerns with the implementation.
-----------------------------------------------------------------------------------------------------
1.Eager initialization
2.Static block initialization
3.Lazy Initialization
4.Thread Safe Singleton
5.Bill Pugh Singleton Implementation
6.Using Reflection to destroy Singleton Pattern
7.Enum Singleton
8.Serialization and Singleton

1.Eager initialization:
------------------------
In eager initialization, the instance of Singleton Class is created at the time of class loading, this is the easiest method to create a singleton class 
but it has a drawback that instance is created even though client application might not be using it.

Ex:
   public class EagerInitializedSingleton {
    
    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();
    
    //private constructor to avoid client applications to use constructor
    private EagerInitializedSingleton(){}

    public static EagerInitializedSingleton getInstance(){
        return instance;
    }

Note:
If your singleton class is not using a lot of resources, this is the approach to use. 
But in most of the scenarios, Singleton classes are created for resources such as File System, Database connections, etc.
We should avoid the instantiation until unless client calls the getInstance method. Also, this method doesn’t provide any options for exception handling.

2.Static block initialization:
------------------------------
static block initialization implementation is similar to eager initialization, except that instance of class is created in the static block 
that provides option for exception handling.

Ex:
public class StaticBlockSingleton {

    private static StaticBlockSingleton instance;
    
    private StaticBlockSingleton(){}
    
    //static block initialization for exception handling
    static{
        try{
            instance = new StaticBlockSingleton();
        }catch(Exception e){
            throw new RuntimeException("Exception occured in creating singleton instance");
        }
    }
    
    public static StaticBlockSingleton getInstance(){
        return instance;
    }
}

*Both eager initialization and static block initialization creates the instance even before it’s being used and 
that is not the best practice to use.

3.Lazy Initialization:
----------------------
Lazy initialization method to implement Singleton pattern creates the instance in the global access method. 
Here is the sample code for creating Singleton class with this approach.

Ex:
public class LazyInitializedSingleton {

    private static LazyInitializedSingleton instance;
    
    private LazyInitializedSingleton(){}
    
    public static LazyInitializedSingleton getInstance(){
        if(instance == null){
            instance = new LazyInitializedSingleton();
        }
        return instance;
    }
}

*The above implementation works fine in case of the single-threaded environment but when it comes to multithreaded systems, 
it can cause issues if multiple threads are inside the if condition at the same time. It will destroy the singleton pattern and both threads 
will get the different instances of the singleton class
-->Factory Design Pattern:
--------------------------
                          Factory Design Pattern used in Frameworks
* The type of objects created will be decided by a separate factory class.
* The Factory design pattern is used when we have a Superclass with multiple sub classes and based on input
  ,we need to return one of the sub class.This pattern takes out the responsibility of the Instatiation of a 
  class from the client program to the factory class























